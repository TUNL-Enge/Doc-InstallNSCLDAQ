# interface generated by SpecTcl version 1.1 from C:/Documents and Settings/fox/Desktop/Menu.ui
#   root     is the parent window for this user interface

proc Menu_ui {root args} {

	# this treats "." as a special case

	if {$root == "."} {
	    set base ""
	} else {
	    set base $root
	}
    
	label $base.label#1 \
		-text {RPI Data Acquisition system Control Panel.}

	label $base.label#2 \
		-text {Acquisition and Analysis}

	button $base.button#2 \
		-command "StartProc $base.button#2 \$BinDir/goReadout Readout $base.output" \
		-text Readout

	button $base.button#8 \
		-command "StartProc $base.button#8 \$BinDir/goScaler  Scaler  $base.output " \
		-text {Scaler Display}

	button $base.button#3 \
		-command "StartProc $base.button#3 \$BinDir/GoSpec SpecTcl" \
		-text SpecTcl

	label $base.label#3 \
		-text {Experimental Controls}

	button $base.button#4 \
		-command "StartProc $base.button#4 \$BinDir/goShaper Shaper $base.output" \
		-text {N568 Amp}

	button $base.button#5 \
		-command "StartProc $base.button#5 \$BinDir/goCfds Cfd $base.output" \
		-text {V812 cfd}

	button $base.button#6 \
		-command "StartProc $base.button#6 \$BinDir/goGDG GDG $base.output" \
		-text {V486 GDG}

	label $base.label#4 \
		-text {Active Process List}

	listbox $base.processes \
		-height 8 \
		-width 0 \
		-yscrollcommand "$base.listscroll set"

	scrollbar $base.listscroll \
		-command "$base.processes yview" \
		-orient v

	label $base.label#5 \
		-text {Output and  Errors.}

	text $base.output \
		-height 1 \
		-width 1 \
		-xscrollcommand "$base.ouhscroll set" \
		-yscrollcommand "$base.outscroll set"

	scrollbar $base.outscroll \
		-command "$base.output yview" \
		-orient v

	scrollbar $base.ouhscroll \
		-command "$base.output xview" \
		-orient h


	# Geometry management

	grid $base.label#1 -in $root	-row 1 -column 1  \
		-columnspan 10
	grid $base.label#2 -in $root	-row 2 -column 4  \
		-columnspan 4
	grid $base.button#2 -in $root	-row 4 -column 2 
	grid $base.button#8 -in $root	-row 4 -column 5  \
		-columnspan 2
	grid $base.button#3 -in $root	-row 4 -column 9 
	grid $base.label#3 -in $root	-row 6 -column 4  \
		-columnspan 4
	grid $base.button#4 -in $root	-row 8 -column 2 
	grid $base.button#5 -in $root	-row 8 -column 5  \
		-columnspan 2
	grid $base.button#6 -in $root	-row 8 -column 9 
	grid $base.label#4 -in $root	-row 11 -column 4  \
		-columnspan 5
	grid $base.processes -in $root	-row 12 -column 2  \
		-columnspan 9 \
		-rowspan 5 \
		-sticky nesw
	grid $base.listscroll -in $root	-row 12 -column 11  \
		-rowspan 5 \
		-sticky nsw
	grid $base.label#5 -in $root	-row 17 -column 4  \
		-columnspan 5
	grid $base.output -in $root	-row 18 -column 2  \
		-columnspan 9 \
		-rowspan 5 \
		-sticky nesw
	grid $base.outscroll -in $root	-row 18 -column 11  \
		-rowspan 5 \
		-sticky nsw
	grid $base.ouhscroll -in $root	-row 23 -column 2  \
		-columnspan 9 \
		-sticky new

	# Resize behavior management

	grid rowconfigure $root 1 -weight 0 -minsize 30
	grid rowconfigure $root 2 -weight 0 -minsize 30
	grid rowconfigure $root 3 -weight 0 -minsize 30
	grid rowconfigure $root 4 -weight 0 -minsize 30
	grid rowconfigure $root 5 -weight 0 -minsize 30
	grid rowconfigure $root 6 -weight 0 -minsize 30
	grid rowconfigure $root 7 -weight 0 -minsize 30
	grid rowconfigure $root 8 -weight 0 -minsize 30
	grid rowconfigure $root 9 -weight 0 -minsize 30
	grid rowconfigure $root 10 -weight 0 -minsize 30
	grid rowconfigure $root 11 -weight 0 -minsize 30
	grid rowconfigure $root 12 -weight 1 -minsize 30
	grid rowconfigure $root 13 -weight 0 -minsize 30
	grid rowconfigure $root 14 -weight 0 -minsize 30
	grid rowconfigure $root 15 -weight 0 -minsize 30
	grid rowconfigure $root 16 -weight 0 -minsize 30
	grid rowconfigure $root 17 -weight 0 -minsize 30
	grid rowconfigure $root 18 -weight 0 -minsize 42
	grid rowconfigure $root 19 -weight 1 -minsize 30
	grid rowconfigure $root 20 -weight 0 -minsize 30
	grid rowconfigure $root 21 -weight 0 -minsize 30
	grid rowconfigure $root 22 -weight 0 -minsize 30
	grid rowconfigure $root 23 -weight 0 -minsize 26
	grid columnconfigure $root 1 -weight 0 -minsize 30
	grid columnconfigure $root 2 -weight 1 -minsize 30
	grid columnconfigure $root 3 -weight 0 -minsize 30
	grid columnconfigure $root 4 -weight 0 -minsize 30
	grid columnconfigure $root 5 -weight 0 -minsize 30
	grid columnconfigure $root 6 -weight 0 -minsize 30
	grid columnconfigure $root 7 -weight 1 -minsize 30
	grid columnconfigure $root 8 -weight 0 -minsize 30
	grid columnconfigure $root 9 -weight 1 -minsize 30
	grid columnconfigure $root 10 -weight 0 -minsize 30
	grid columnconfigure $root 11 -weight 0 -minsize 30
# additional interface code
package require Wait
global env
global BinDir
global Processes
global WidgetRoot


if {[array names env BinDir] == ""} {
   set BinDir ~/bin
} else {
   set BinDir $env(BinDir)
}
set WidgetRoot $base
#
#  Monitor a process for exit.
#  When the process exits, enable its widget.
#
proc MonitorPid {pid widget} {
  global Processes
  
  set status [catch  "Wait -pid $pid -poll" result]
  
  # If the catch fails, enable the widget too:
  # Since in tk the reaper may have caught this automatically.
  
   if {$status > 0} {
      $widget configure -state normal
      catch "unset Processes($pid)"
      UpdateProcessList
      return
   }
   if {$result == $pid} {
      $widget configure -state normal
      catch "unset Processes($pid)"
      UpdateProcessList
      return
   }
   after 300 "MonitorPid $pid $widget"
}
#
#   Process input from a pipeline and put it in the associated
#   text widget:
#
proc ProcessInput {fd textwidget shortname} {
   if {[eof $fd]} {
      puts "Closing $fd"
      fileevent $fd readable ""
      catch "close $fd"
   } else {
      set status [catch "gets $fd line"]
      if {$status == 0} {
	      $textwidget insert end "$shortname: $line\n"
	      $textwidget see end
      }
   }
}
#
#   Start a process off in the background and ghost it's startup
#   Button.
#  
proc StartProc {widget command {shortname ""} {outwidget ""} } {
	global Processes
	$widget configure -state disabled
	if {$outwidget != ""} {
		set fd [open "| $command" r]
		fileevent $fd readable \
			[list ProcessInput $fd $outwidget $shortname]
		set pid [pid $fd]
	} else {
	    set pid [exec $command &]

        }
	if {$shortname != ""} {
		set command "$shortname: $command"
	}
	set Processes($pid) $command
	MonitorPid $pid $widget 
	UpdateProcessList

}
#
#   Update process list box:
#
proc UpdateProcessList {} {
   global WidgetRoot
   global Processes
   
  $WidgetRoot.processes delete 0 end  
  
  if {[array names Processes] != ""} { 
   
      # Clear the box:
   
 
   
      foreach pid [array names Processes]  {
          $WidgetRoot.processes insert end $Processes($pid)
      }   

   }

}

#
#  Send a kill to all processes to shut them down. 
#
proc StopAll {} {
   global Processes
   foreach pid [array names Processes] {
      puts "Killing $pid"
      exec kill -TERM $pid
   }
}


# end additional interface code

}


# Allow interface to be run "stand-alone" for testing

catch {
    if [info exists embed_args] {
	# we are running in the plugin
	Menu_ui .
    } else {
	# we are running in stand-alone mode
	if {$argv0 == [info script]} {
	    wm title . "Testing Menu_ui"
	    Menu_ui .
	}
    }
}
